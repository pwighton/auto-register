#!/usr/bin/env python

"""Register two images by calling out to a helper executable (default
is mri_robust_register). The resulting transformation is read from the
output file generated by the registration executable, and made
available to other modules.

This file can also be used in standalone mode for testing or
reproducing the AutoRegister behavior.

"""

import argparse
import nibabel as nb
import numpy as np
import os
import sys
import subprocess
import re

class RegisteredImage:
    """Class that registers two images and stores info about the registration.
    """

    _reg_prog = 'mri_robust_register'

    @classmethod
    def check_environment(cls):
        """Make sure that our environment is able to execute the registration
        program.
        """

        cmd = [cls._reg_prog]

        try:
            check_proc = subprocess.Popen(cmd,
                                          stdout=subprocess.PIPE,
                                          stderr=subprocess.PIPE)
            out, err = check_proc.communicate()

            if (check_proc.returncode == 1 and
                out.find(cls._reg_prog) != -1):
                return True
            else:
                print "Unexpected output while executing %s" % cls._reg_prog
                return False

        except(OSError):
            print "Can't find %s, make sure it's in the $PATH?" % cls._reg_prog
            return False

    @classmethod
    def read_transform_file(cls, filename):
        """Read and LTA file and parse the transformation it contains.
        """
        with open(filename) as f:
            transform_line_re = re.compile('([0-9.e\-\+]+\s){4}')
            transform = ''
            num_consecutive_transform_lines = 0
            for line in f:
                if transform_line_re.match(line):
                    transform += line.strip() + ' '
                    num_consecutive_transform_lines += 1
                else:
                    if num_consecutive_transform_lines == 4:
                        break
                    else:
                        num_consecutive_transform_lines = 0
                        transform = ''

            # validate
            if num_consecutive_transform_lines != 4:
                print "Transform file ended unexpectedly"
                return ''

            T = np.eye(4)
            Ts = transform.split();
            for r in xrange(4):
                for c in xrange(4):
                    T[r][c] = float(Ts.pop(0))

            return T

        return None

    def __init__(self, reference, movable, opts=None, verbose=False):
        """Setup for performing registrations.
        """

        self._reference = reference
        self._movable = movable
        self._verbose = verbose

        self._robust_reg_options = ['--satit',
                                    '--iscale']

        if opts is not None:
            self._robust_reg_options += opts

        if self._verbose:
            print "using robust register options: "
            print self._robust_reg_options

        self._transform_file = None

    def get_transform_filename(self):
        """Return the name of the most recently computed transform.
        """

        return self._transform_file

    def get_transform(self):
        """Retrieve a 4x4 numpy matrix representing the most recently computed
        transform.
        """

        T = RegisteredImage.read_transform_file(self._transform_file)

        ref = nb.load(self._reference)
        mov = nb.load(self._movable)

        # account for reference vox2ras
        ref_vox2ras = ref.get_affine()
        mov_vox2ras = mov.get_affine()
        Fov = np.dot(ref_vox2ras, np.linalg.inv(mov_vox2ras))
        T = np.dot(T, Fov)

        # RAS -> LPS
        flip = np.eye(4)
        flip[0][0] = -1
        flip[1][1] = -1

        T = np.dot(np.dot(flip, T), flip)

        if self._verbose:
            print "FOV:"
            print Fov
            print "T:"
            print T

        # convert to string (the dumb way)
        T_str = ''
        for r in xrange(4):
            for c in xrange(4):
                T_str += "%0.9f " % T[r][c]

        return T_str


    def register(self):
        """Call out to the external program to register the reference and
        movable images.
        """

        out_stem = '.'.join(self._movable.split('.')[:-1])

        # also handle .nii.gz files
        if out_stem.endswith('.nii'):
            out_stem = out_stem[:-4]

        self._transform_file = out_stem + '.lta'

        cmd = [self._reg_prog,
               '--mov', self._reference,
               '--dst', self._movable,
               '--lta', self._transform_file,
               '--mapmov', out_stem + '_map.nii.gz',
               '--weights', out_stem + '_weights.nii.gz',
              ] + self._robust_reg_options

        if self._verbose:
            print ' '.join(cmd)

        try:
            reg_proc = subprocess.Popen(cmd,
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.PIPE)
            out, err = reg_proc.communicate()

            if reg_proc.returncode == 0:
                with open(out_stem + '.log', 'w') as log:
                    log.write(out)
            else:
                print "Failure executing command:"
                print cmd
                print err
                return False

        except(OSError):
            print ("Error executing subprocess for registration, perhaps %s is "
                   "not in the $PATH?" % self._reg_prog)
            return False

        return True


def main(argv):
    """During standalone operation, build all the arguments that would
    normally be passed in from the calling module and pass them into a
    RegisteredImage class instance.
    """

    def verifyPathExists(path):
        if not os.path.exists(path):
            raise ValueError("%s does not exist" % path)
        return path

    def verifyDirExists(path):
        if not os.path.isdir(path):
            raise ValueError("%s does not exist" % path)
        return path

    def splitOptions(opts):
        if opts is None or opts == '':
            return None
        return opts.split()

    # parse args
    parser = argparse.ArgumentParser()
    parser.add_argument('reference', type=verifyPathExists,
                        help='Path to nifti image to use as the reference '
                        'image for registration')
    parser.add_argument('movable', type=verifyPathExists,
                        help='Path to nifti image to use as the movable '
                        'image for registration')
    parser.add_argument('-o', '--options', type=splitOptions,
                        help='Extra options to pass mri_robust_register')
    parser.add_argument('-v', '--verbose', action="store_true",
                        help='Enable verbose output')

    args = parser.parse_args()

    ri = RegisteredImage(args.reference, args.movable,
                         opts=args.options, verbose=args.verbose)

    print "Registering %s to %s" % (args.movable, args.reference)

    if ri.register():
        print "Registration completed"
    else:
        print "Registration failed"


if __name__ == "__main__":
    sys.exit(main(sys.argv))
